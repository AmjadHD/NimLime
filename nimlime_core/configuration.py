# coding=utf-8
"""
Global configuration
This file loads and verifies the more global and complex aspects of NimLime's
settings and configuration.
"""
import os
from os.path import realpath

import sublime
from nimlime_core import settings
from nimlime_core.utils.misc import format_msg

# Package state
is_zipped = not os.path.isfile(__file__)

# OS Conditionals
on_windows = False
on_linux = False
on_mac = False

platform = sublime.platform()

if platform == 'windows':
    on_windows = True
elif platform == 'linux':
    on_linux = True
elif platform == 'osx':
    on_mac = True

# Executable finding
not_found_msg = format_msg("""
    The {0} executable could not be found.\\n\\n
    NimLime commands requiring a working {0} install are disabled.\\n
    Please make sure that either the {0} executable is in your PATH
    environment variable, or that the '{1}' entry in
    NimLime's settings is set to a valid path.\\n\\n
    To disable this message, set the '{1}.check_configuration' setting
    in NimLime's settings file to 'False'.
    """)

nimsuggest_not_found_msg = format_msg("""\\n
    NOTE: The Nimsuggest must be the versions generated by the
    'setup nimsuggest' command.\\n
    """) + not_found_msg


def split_pathlist(string):
    """
    :type string: str
    """
    pathsep = os.pathsep

    sections = []
    found_caret = False
    start = 0
    end = 0
    for end, character in enumerate(string):
        if found_caret:
            found_caret = False
            sections.append(string[start:end - 1])
            start = end
            continue

        if on_windows and character == '^':
            found_caret = True
        elif character == pathsep:
            sections.append(string[start:end])
            start = end + 1
            yield ''.join(sections)
            sections = []

    if start != end + 1:
        sections.append(string[start:end + 1])
    yield ''.join(sections)


path_var_list = split_pathlist(os.environ.get('PATH', ''))


def possible_exe_paths(exe_value, default_exe_value):
    """
    Generate possible paths the given executable may be in, in order of
    greatest likelihood to least.
    :type exe_value: str
    :type default_exe_value: str
    """
    exe_value_as_path = realpath(exe_value)

    # Direct path to exe
    yield exe_value_as_path
    if on_windows:
        yield exe_value_as_path + '.exe'

    # Values in path
    for path in path_var_list:
        possible_exe_path = os.path.join(path, exe_value)
        yield possible_exe_path
        if on_windows:
            yield possible_exe_path + '.exe'

    # Directory containing exe?
    yield os.path.join(exe_value_as_path, default_exe_value)


def gen_exe_check(program_name, setting_key, default_exe, message=None):
    """
    Generates a function that checks if a program is on the path, based off
    of settings. May also notify the user if the check can't find the
    executable or the executable doesn't exist.
    :type message: str
    :type default_exe: str
    :type setting_key: str
    :type program_name: str
    :rtype: () -> str
    """

    def _load():
        # Get the current executable, and look for the file.
        current_exe = settings.get(setting_key, default_exe)
        for path in possible_exe_paths(current_exe, default_exe):
            if os.path.isfile(path):
                executable_path = path
                break

        # Optionally notify the user.
        if executable_path is None and current_exe != _load.old_exe:
            if settings.get('check_configuration', True):
                # Needed due to a bug in ST2 - Main window won't appear
                # if inturrupted by an error message.
                def callback():
                    if sublime.active_window() is None:
                        sublime.set_timeout(callback, 500)
                        return
                    sublime.error_message(
                        (message or not_found_msg).format(
                            program_name, setting_key
                        )
                    )

                callback()

        # Store the old path, so that we don't end up notifying the user twice
        # over an unchanged path.
        _load.old_exe = current_exe
        return executable_path

    _load.old_exe = ''
    return _load


nimble_executable = 'nimble'
nim_executable = 'nim'
nimsuggest_executable = 'nimsuggest'

_nimble_exe_check = gen_exe_check('Nimble', 'nimble.executable', 'nimble.exe')
_nim_exe_check = gen_exe_check('Nim', 'nim.executable', 'nim.exe')
_nimsuggest_exe_check = gen_exe_check('Nimsuggest', 'nimsuggest.executable',
                                      'nimsuggest.exe',
                                      nimsuggest_not_found_msg)


def _check_for_nimble_exe():
    global nimble_executable
    nimble_executable = _nimble_exe_check()


def _check_for_nim_exe():
    global nim_executable
    nim_executable = _nim_exe_check()


def _check_for_nimsuggest_exe():
    global nimsuggest_executable
    nimsuggest_executable = _nimsuggest_exe_check()


settings.run_on_load_and_change('nimble.executable', _check_for_nimble_exe)
settings.run_on_load_and_change('nim.executable', _check_for_nim_exe)
settings.run_on_load_and_change('nimsuggest.executable',
                                _check_for_nimsuggest_exe)
